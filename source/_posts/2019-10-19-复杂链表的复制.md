---
title: 复杂链表的复制
date: 2019-10-19 10:11:01
tags:
- 题解
- 链表
categories:
- 剑指
---

# Question
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
<!-- more -->

# Solution
*这题的random指针有点特殊，和next指针的性质不用，random指向的是next能遍历到的，即本身链表存在的指针，不会生成新的指针。*

具体步骤如下：

1. 复制链表，将A->B->C转换成A->A'->B->B'->C->C'的结构

2. 找到random，遍历链表：A'->random = A->random->next ##这里就是random是本身存在与next的遍历中的，不然无法在第一步中复制

3. 拆分链表，将A->A'->B->B'->C->C'转换成A->B->C的结构和A'->B'->C'两个链表

![图解](/images/2019101901.png)

# Code

**python:**

```python
# -*- coding:utf-8 -*-
# class RandomListNode:
#     def __init__(self, x):
#         self.label = x
#         self.next = None
#         self.random = None
class Solution:
    # 返回 RandomListNode
    def Clone(self, pHead):
        # write code here
        if pHead == None:
            return None
        cpHead = pHead
        while cpHead != None:
            tmp = RandomListNode(cpHead.label)
            tmp.next = cpHead.next
            cpHead.next = tmp
            cpHead = tmp.next
        cpHead = pHead
        while cpHead != None:
            cpNode = cpHead.next
            cpNode.random = cpHead.random.next if cpHead.random else None
            cpHead = cpNode.next
        cpHead = pHead
        ans = pHead.next
        while cpHead:
            cpNode = cpHead.next
            cpHead.next = cpNode.next
            cpHead = cpNode.next
            cpNode.next = cpHead.next if cpHead else None
        return ans
            
```


---
title: 139. 单词拆分
date: 2019-07-13 16:41:25
tags:
- 题解
- Medium
- 动态规划
- 递归
categories:
- LeetCode
---

# Question

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

<!--more-->

**说明：**

* 拆分时可以重复使用字典中的单词。
* 你可以假设字典中没有重复的单词。

**示例 1：**
```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```

**示例 2：**
```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
```

**示例 3：**
```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

# Solution

1.递归回溯

若一个单词可以分解，则必有一个单词是`s`的前缀，将`s`分成两部分，若前一部分是一个单词，则判断后一部分是否可以分解，若后一部分也可以分解，则整个`s`都可以分解，这后一部分`s`和整个`s`的问题相似，所以利用递归求解子问题，将子问题结果用于这一层的求解。

python	
```Python
class Solution:
    def wb(self, s, myset, mem):
        if s in mem:
            return mem[s]
        length = len(s)
        if length == 0:
            return True
        for i in range(1,length+1):
            if s[:i] in myset and self.wb(s[i:],myset,mem):
                mem[s] = True
                return True
        mem[s] = False
        return False
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        mem = dict()
        myset = set(wordDict)
        return self.wb(s, myset, mem)
```
2.动态规划

假设当前要求`s[:i]`的结果，且`s[:i-1]`的结果已知。利用之前已经求出的解来解决当前问题，后面的问题也同样依赖当前的解作为已求解，这样的求解方式就是动态规划。

本题方法：设置dp数组，`dp[i]`表示字符串`s[:i]`是否是可分解的。`dp[i]`求解：将`s[:i]`以j分解成两部分`s[:j]`和`s[j:i]`,若`dp[j]==True`，且`s[j:i]`是一个单词，则`dp[i]=True`。由于是判断后一部分是否为单词，所以将`j`从`i`开始递减判断,以此减少一些判断。

python
```Python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        myset = set(wordDict)
        dp = [False for i in range(len(s)+1)]
        dp[0] = True
        for i in range(1,len(s)+1):
            for j in range(i+1)[::-1]:
                if dp[j] and s[j:i] in myset:
                    dp[i] = True
                    break
        return dp[len(s)]
```
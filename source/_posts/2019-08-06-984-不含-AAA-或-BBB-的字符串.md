---
title: 984. 不含 AAA 或 BBB 的字符串
date: 2019-08-06 20:29:02
tags:
- 题解
- Medium
- 贪心算法
- 递归
categories:
- LeetCode
---

# Question

给定两个整数 A 和 B，返回任意字符串 S，要求满足：

S 的长度为 A + B，且正好包含 A 个 'a' 字母与 B 个 'b' 字母；
子串 'aaa' 没有出现在 S 中；
子串 'bbb' 没有出现在 S 中。

<!--more-->

**示例 1：**

```
输入：A = 1, B = 2
输出："abb"
解释："abb", "bab" 和 "bba" 都是正确答案。
```

**示例 2：**

```
输入：A = 4, B = 1
输出："aabaa"
```

**提示：**

1. 0 <= A <= 100
2. 0 <= B <= 100
3. 对于给定的 A 和 B，保证存在满足要求的 S。

# Solution

贪心算法：贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。即不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解，而这种局部最优也即是全局最优。

官方题解的思想：设A为所剩数量多的字母，只有当已经连续A出现，否则下一个还是插入A，在插入的过程中不断判断何为剩余多的字母。

我的方法：假设B>A，则直观的插法，两个BB,一个A，这样去插入，即BBABBA···这种形式，这样当B全部插完之后，若A还有剩余，再从头开始将之前的BB中间再插入一个A。大概思想就是这样，但有一些细节问题：
1. 当MAX(A,B)==1时，属于特殊情况
2. BBABB这种情况要考虑，即最后一个A不是必要的，也即A的数量>=B/2-1.
3. BABABABA即A=B且B%2==1的特殊情况。
上述细节都是对于我的代码而言，因为我是两个带一个这样插入的。

```Python
class Solution:
    def strWithout3a3b(self, A: int, B: int) -> str:
        alpha = list(zip([A,B],['a','b']))
        #left insert to right
        if A > B:
            alpha = list(reversed(alpha))
        if alpha[1][0] <= 1:
            return alpha[1][0]*alpha[1][1]+alpha[0][1]*alpha[0][0]
        ans = ''
        m,n = divmod(alpha[1][0],2)
        cnt = alpha[0][0]
        for i in range(0,m):
            ans += alpha[1][1]*2
            ans += alpha[0][1]
            cnt -= 1
        if cnt == -1:
            ans = ans[:-1]
            cnt = 0
        if n :
            ans += alpha[1][1]
        if cnt > 0:
            ans = ans.replace(alpha[1][1]+alpha[1][1],alpha[1][1]+alpha[0][1]+alpha[1][1],cnt)
        if len(ans) < A+B:
            ans += alpha[0][1]*(A+B-len(ans))
        return ans
          
```


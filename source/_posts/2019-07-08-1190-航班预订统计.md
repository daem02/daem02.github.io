---
title: 1190.航班预订统计
date: 2019-07-08 20:12:16
tags:
- Medium
- 题解
- 差分
categories:
- LeetCode
---

# Question
这里有 n 个航班，它们分别从 1 到 n 进行编号。我们这儿有一份航班预订表，表中第 i 条预订记录 bookings[i] = [i, j, k] 意味着我们在从 i 到 j 的每个航班上预订了 k 个座位。请你返回一个长度为 n 的数组 answer，按航班编号顺序返回每个航班上预订的座位数。

<!--more-->

示例:
```
输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
```

提示:
```
1 <= bookings.length <= 20000
1 <= bookings[i][0] <= bookings[i][1] <= n <= 20000
1 <= bookings[i][2] <= 10000
```

# Solution

首先想到的是暴力求解，设置一个数组`corp[n]`,遍历`bookings`，对于每一个`bookings[i]`，将`i`到`j`之间的所有`corp[m]`都加上`K`。但是无疑超时了。

然后是利用差分的思想，设置一个数组`corp[n]`,每个`corp[i]`意义为 其比前一个`corp[i-1]`多出的航班座位数目。遍历`bookings`，对于每一个`bookings[i]`，将`corp[i]+k`,将`corp[j+1]-k`,这样`i`到`j`的航班座位数就能够根据首尾的两个值计算出来。公式是`corp[i]=corp[i]+corp[i-1]`。

Java:
```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] tag = new int[n];
        for (int[] book : bookings){
            tag[book[0]-1] += book[2];
            int j = book[1];
            if (j<n){
                tag[j]-=book[2];
            }
        }
        for (int i=1;i<n;i++){
            tag[i]=tag[i-1]+tag[i];
        }
        return tag;
    }
}
```
Python
```python
class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        answer = [0]*n
        for i in bookings:
            answer[i[0]-1]+=i[2]
            if i[1]<n:
                answer[i[1]]-=i[2]
        for i in range(1,n):
            answer[i]=answer[i-1]+answer[i]
        return answer
```
